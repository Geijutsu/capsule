// NixOS Configuration Generator for Capsule

use crate::config::{collect_packages, load_preset, Config};
use anyhow::{Context, Result};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Service configuration mapping
#[derive(Debug, Clone)]
pub struct ServiceMapping {
    pub services: HashMap<String, serde_json::Value>,
}

impl ServiceMapping {
    pub fn new() -> Self {
        Self {
            services: HashMap::new(),
        }
    }
}

/// NixOS Configuration Generator
pub struct NixOSConfigGenerator {
    capsule_dir: PathBuf,
}

impl NixOSConfigGenerator {
    /// Create a new generator
    pub fn new(capsule_dir: Option<PathBuf>) -> Self {
        let capsule_dir = capsule_dir.unwrap_or_else(|| {
            dirs::home_dir()
                .expect("Could not find home directory")
                .join(".capsule")
        });

        Self { capsule_dir }
    }

    /// Detect and map services from presets
    pub fn detect_services(&self, config: &Config) -> HashMap<String, String> {
        let mut services = HashMap::new();
        let presets = &config.presets;

        // Service mapping
        let service_map: HashMap<&str, Vec<(&str, &str)>> = [
            ("docker", vec![
                ("virtualisation.docker.enable", "true"),
                ("virtualisation.docker.enableOnBoot", "true"),
            ]),
            ("webserver", vec![
                ("services.nginx.enable", "true"),
                ("networking.firewall.allowedTCPPorts", "[ 80 443 ]"),
            ]),
            ("database", vec![
                ("services.postgresql.enable", "true"),
                ("services.postgresql.enableTCPIP", "true"),
            ]),
            ("monitoring", vec![
                ("services.prometheus.enable", "true"),
                ("services.grafana.enable", "true"),
            ]),
        ].iter().cloned().collect();

        for preset_name in presets {
            if let Some(service_config) = service_map.get(preset_name.as_str()) {
                for (key, value) in service_config {
                    services.insert(key.to_string(), value.to_string());
                }
            }
        }

        services
    }

    /// Generate configuration.nix
    pub fn generate_configuration_nix(
        &self,
        profile: &Config,
        hostname: &str,
        username: &str,
    ) -> Result<String> {
        let (_, packages_by_preset) = collect_packages(profile)?;
        let services = self.detect_services(profile);

        let mut lines = Vec::new();

        // Header
        lines.push("# NixOS Configuration".to_string());
        lines.push(format!(
            "# Generated by Capsule on {}",
            chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
        ));
        lines.push(format!(
            "# Profile: {}",
            profile.description.as_ref().unwrap_or(&"Custom configuration".to_string())
        ));
        lines.push("".to_string());
        lines.push("{ config, pkgs, ... }:".to_string());
        lines.push("".to_string());
        lines.push("{".to_string());
        lines.push("  imports = [".to_string());
        lines.push("    ./hardware-configuration.nix".to_string());
        lines.push("  ];".to_string());
        lines.push("".to_string());

        // Boot loader
        lines.push("  # Boot loader".to_string());
        lines.push("  boot.loader.systemd-boot.enable = true;".to_string());
        lines.push("  boot.loader.efi.canTouchEfiVariables = true;".to_string());
        lines.push("".to_string());

        // Network configuration
        lines.push("  # Network configuration".to_string());
        lines.push(format!("  networking.hostName = \"{}\";", hostname));
        lines.push("  networking.networkmanager.enable = true;".to_string());
        lines.push("".to_string());

        // Time zone and locale
        lines.push("  # Localization".to_string());
        lines.push("  time.timeZone = \"America/New_York\";".to_string());
        lines.push("  i18n.defaultLocale = \"en_US.UTF-8\";".to_string());
        lines.push("".to_string());

        // User accounts
        lines.push("  # User accounts".to_string());
        lines.push(format!("  users.users.{} = {{", username));
        lines.push("    isNormalUser = true;".to_string());
        lines.push("    description = \"Primary User\";".to_string());
        lines.push("    extraGroups = [ \"wheel\" \"networkmanager\" \"docker\" ];".to_string());
        lines.push("    openssh.authorizedKeys.keys = [".to_string());
        lines.push("      # Add your SSH public keys here".to_string());
        lines.push("    ];".to_string());
        lines.push("  };".to_string());
        lines.push("".to_string());

        // Services configuration
        if !services.is_empty() {
            lines.push("  # Services".to_string());
            for (key, value) in services.iter() {
                if key.starts_with("#") {
                    lines.push(format!("  {}", key));
                } else {
                    lines.push(format!("  {} = {};", key, value));
                }
            }
            lines.push("".to_string());
        }

        // SSH configuration
        lines.push("  # SSH".to_string());
        lines.push("  services.openssh = {".to_string());
        lines.push("    enable = true;".to_string());
        lines.push("    settings = {".to_string());
        lines.push("      PermitRootLogin = \"no\";".to_string());
        lines.push("      PasswordAuthentication = false;".to_string());
        lines.push("    };".to_string());
        lines.push("  };".to_string());
        lines.push("".to_string());

        // Firewall
        lines.push("  # Firewall".to_string());
        lines.push("  networking.firewall = {".to_string());
        lines.push("    enable = true;".to_string());
        lines.push("    allowedTCPPorts = [ 22 ];".to_string());
        lines.push("    # allowedUDPPorts = [ ... ];".to_string());
        lines.push("  };".to_string());
        lines.push("".to_string());

        // System packages
        lines.push("  # System packages".to_string());
        lines.push("  environment.systemPackages = with pkgs; [".to_string());

        // Add packages grouped by preset
        for preset_name in ["base", "custom"]
            .iter()
            .copied()
            .chain(profile.presets.iter().map(|s| s.as_str()))
        {
            if let Some(packages) = packages_by_preset.get(preset_name) {
                if packages.is_empty() {
                    continue;
                }

                let description = if preset_name == "base" {
                    "Base system packages".to_string()
                } else if preset_name == "custom" {
                    "Custom packages".to_string()
                } else if let Ok(Some(preset)) = load_preset(preset_name) {
                    preset.description
                } else {
                    preset_name.to_string()
                };

                lines.push(format!("    # {}", description));
                for pkg in packages {
                    lines.push(format!("    {}", pkg));
                }
                lines.push("".to_string());
            }
        }

        lines.push("  ];".to_string());
        lines.push("".to_string());

        // Nix settings
        lines.push("  # Nix settings".to_string());
        lines.push("  nix.settings = {".to_string());
        lines.push("    experimental-features = [ \"nix-command\" \"flakes\" ];".to_string());
        lines.push("    auto-optimise-store = true;".to_string());
        lines.push("  };".to_string());
        lines.push("".to_string());
        lines.push("  # Automatic garbage collection".to_string());
        lines.push("  nix.gc = {".to_string());
        lines.push("    automatic = true;".to_string());
        lines.push("    dates = \"weekly\";".to_string());
        lines.push("    options = \"--delete-older-than 30d\";".to_string());
        lines.push("  };".to_string());
        lines.push("".to_string());

        // System version
        lines.push("  # System version".to_string());
        lines.push("  system.stateVersion = \"24.05\"; # Don't change this!".to_string());
        lines.push("}".to_string());

        Ok(lines.join("\n"))
    }

    /// Generate home-manager configuration
    pub fn generate_home_manager(&self, profile: &Config, username: &str) -> Result<String> {
        let (_, packages_by_preset) = collect_packages(profile)?;

        let mut lines = Vec::new();

        lines.push("# Home Manager Configuration".to_string());
        lines.push(format!(
            "# Generated by Capsule on {}",
            chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
        ));
        lines.push(format!(
            "# Profile: {}",
            profile.description.as_ref().unwrap_or(&"Custom configuration".to_string())
        ));
        lines.push("".to_string());
        lines.push("{ config, pkgs, ... }:".to_string());
        lines.push("".to_string());
        lines.push("{".to_string());
        lines.push(format!("  home.username = \"{}\";", username));
        lines.push(format!("  home.homeDirectory = \"/home/{}\";", username));
        lines.push("".to_string());
        lines.push("  # Home Manager version (match your NixOS version)".to_string());
        lines.push("  home.stateVersion = \"24.05\";".to_string());
        lines.push("".to_string());
        lines.push("  # Let Home Manager install and manage itself".to_string());
        lines.push("  programs.home-manager.enable = true;".to_string());
        lines.push("".to_string());

        // User packages
        lines.push("  # User packages".to_string());
        lines.push("  home.packages = with pkgs; [".to_string());

        for preset_name in ["base", "custom"]
            .iter()
            .copied()
            .chain(profile.presets.iter().map(|s| s.as_str()))
        {
            if let Some(packages) = packages_by_preset.get(preset_name) {
                if packages.is_empty() {
                    continue;
                }

                let description = if preset_name == "base" {
                    "Base packages".to_string()
                } else if preset_name == "custom" {
                    "Custom packages".to_string()
                } else if let Ok(Some(preset)) = load_preset(preset_name) {
                    preset.description
                } else {
                    preset_name.to_string()
                };

                lines.push(format!("    # {}", description));
                for pkg in packages {
                    lines.push(format!("    {}", pkg));
                }
                lines.push("".to_string());
            }
        }

        lines.push("  ];".to_string());
        lines.push("".to_string());

        // Shell configuration
        let default_editor = "vim".to_string();
        let editor = profile.editor.as_ref().unwrap_or(&default_editor);
        lines.push("  # Shell configuration".to_string());
        lines.push("  programs.bash = {".to_string());
        lines.push("    enable = true;".to_string());
        lines.push("    shellAliases = {".to_string());
        lines.push("      ll = \"ls -la\";".to_string());
        lines.push("      gs = \"git status\";".to_string());
        lines.push("      gd = \"git diff\";".to_string());
        lines.push("    };".to_string());
        lines.push("  };".to_string());
        lines.push("".to_string());
        lines.push("  # Editor".to_string());
        lines.push("  home.sessionVariables = {".to_string());
        lines.push(format!("    EDITOR = \"{}\";", editor));
        lines.push("  };".to_string());
        lines.push("".to_string());

        // Git configuration
        if profile.presets.contains(&"github".to_string()) {
            lines.push("  # Git configuration".to_string());
            lines.push("  programs.git = {".to_string());
            lines.push("    enable = true;".to_string());
            lines.push("    userName = \"Your Name\";".to_string());
            lines.push("    userEmail = \"your.email@example.com\";".to_string());
            lines.push("    extraConfig = {".to_string());
            lines.push("      init.defaultBranch = \"main\";".to_string());
            lines.push("      pull.rebase = false;".to_string());
            lines.push("    };".to_string());
            lines.push("  };".to_string());
            lines.push("".to_string());
        }

        // Direnv for development environments
        if profile.presets.contains(&"devtools".to_string())
            || profile.presets.contains(&"python".to_string())
        {
            lines.push("  # Development tools".to_string());
            lines.push("  programs.direnv = {".to_string());
            lines.push("    enable = true;".to_string());
            lines.push("    nix-direnv.enable = true;".to_string());
            lines.push("  };".to_string());
            lines.push("".to_string());
        }

        lines.push("}".to_string());

        Ok(lines.join("\n"))
    }

    /// Generate flake.nix
    pub fn generate_flake_nix(
        &self,
        profile: &Config,
        hostname: &str,
        username: &str,
    ) -> Result<String> {
        let mut lines = Vec::new();

        lines.push("{".to_string());
        lines.push("  description = \"NixOS configuration with Capsule-generated setup\";".to_string());
        lines.push("".to_string());
        lines.push("  inputs = {".to_string());
        lines.push("    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-24.05\";".to_string());
        lines.push("    home-manager = {".to_string());
        lines.push("      url = \"github:nix-community/home-manager/release-24.05\";".to_string());
        lines.push("      inputs.nixpkgs.follows = \"nixpkgs\";".to_string());
        lines.push("    };".to_string());
        lines.push("  };".to_string());
        lines.push("".to_string());
        lines.push("  outputs = { self, nixpkgs, home-manager, ... }@inputs: {".to_string());
        lines.push(format!("    nixosConfigurations.{} = nixpkgs.lib.nixosSystem {{", hostname));
        lines.push("      system = \"x86_64-linux\";".to_string());
        lines.push("      modules = [".to_string());
        lines.push("        ./configuration.nix".to_string());
        lines.push("        home-manager.nixosModules.home-manager".to_string());
        lines.push("        {".to_string());
        lines.push("          home-manager.useGlobalPkgs = true;".to_string());
        lines.push("          home-manager.useUserPackages = true;".to_string());
        lines.push(format!("          home-manager.users.{} = import ./home.nix;", username));
        lines.push("        }".to_string());
        lines.push("      ];".to_string());
        lines.push("    };".to_string());
        lines.push("  };".to_string());
        lines.push("}".to_string());

        Ok(lines.join("\n"))
    }

    /// Generate hardware-configuration.nix
    pub fn generate_hardware_config(&self) -> Result<String> {
        // Try to run nixos-generate-config to detect hardware
        let output = Command::new("nixos-generate-config")
            .arg("--show-hardware-config")
            .output();

        if let Ok(output) = output {
            if output.status.success() {
                if let Ok(config) = String::from_utf8(output.stdout) {
                    return Ok(config);
                }
            }
        }

        // Return template if hardware detection fails
        Ok(r#"# Hardware Configuration
# This is a template - run 'nixos-generate-config' on the target system

{ config, lib, pkgs, modulesPath, ... }:

{
  imports = [
    (modulesPath + "/profiles/qemu-guest.nix")
  ];

  boot.initrd.availableKernelModules = [ "ata_piix" "uhci_hcd" "virtio_pci" "sd_mod" "sr_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ ];
  boot.extraModulePackages = [ ];

  fileSystems."/" = {
    device = "/dev/disk/by-label/nixos";
    fsType = "ext4";
  };

  fileSystems."/boot" = {
    device = "/dev/disk/by-label/boot";
    fsType = "vfat";
  };

  swapDevices = [ ];

  networking.useDHCP = lib.mkDefault true;
  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
}
"#.to_string())
    }

    /// Generate all NixOS configuration files
    pub fn generate_all(
        &self,
        profile: &Config,
        output_dir: &Path,
        hostname: &str,
        username: &str,
    ) -> Result<HashMap<String, PathBuf>> {
        std::fs::create_dir_all(output_dir)?;

        let mut generated_files = HashMap::new();

        // Generate configuration.nix
        let config_nix = self.generate_configuration_nix(profile, hostname, username)?;
        let config_path = output_dir.join("configuration.nix");
        std::fs::write(&config_path, config_nix)?;
        generated_files.insert("configuration.nix".to_string(), config_path);

        // Generate home.nix
        let home_nix = self.generate_home_manager(profile, username)?;
        let home_path = output_dir.join("home.nix");
        std::fs::write(&home_path, home_nix)?;
        generated_files.insert("home.nix".to_string(), home_path);

        // Generate flake.nix
        let flake_nix = self.generate_flake_nix(profile, hostname, username)?;
        let flake_path = output_dir.join("flake.nix");
        std::fs::write(&flake_path, flake_nix)?;
        generated_files.insert("flake.nix".to_string(), flake_path);

        // Generate hardware-configuration.nix
        let hardware_nix = self.generate_hardware_config()?;
        let hardware_path = output_dir.join("hardware-configuration.nix");
        std::fs::write(&hardware_path, hardware_nix)?;
        generated_files.insert("hardware-configuration.nix".to_string(), hardware_path);

        // Create README
        let readme_content = format!(r#"# NixOS Configuration

Generated by Capsule on {}

## Files

- **configuration.nix**: System-wide configuration
- **home.nix**: Home Manager user configuration
- **flake.nix**: Nix flakes configuration (modern approach)
- **hardware-configuration.nix**: Hardware-specific configuration

## Usage

### Traditional NixOS (configuration.nix)

1. Copy configuration.nix and hardware-configuration.nix to /etc/nixos/
2. Review and customize the configuration
3. Run: `sudo nixos-rebuild switch`

### With Flakes (recommended)

1. Copy all files to /etc/nixos/
2. Run: `sudo nixos-rebuild switch --flake /etc/nixos#{}`

### With Home Manager

1. Install Home Manager: https://github.com/nix-community/home-manager
2. Copy home.nix to ~/.config/home-manager/
3. Run: `home-manager switch`

## Customization

- Update hostname in configuration.nix
- Add SSH keys in users.users.{}.openssh.authorizedKeys.keys
- Adjust timezone in time.timeZone
- Modify firewall rules in networking.firewall
- Add additional packages to environment.systemPackages

## Testing

Test in a VM before deploying:
```bash
sudo nixos-rebuild build-vm
./result/bin/run-nixos-vm
```
"#, chrono::Local::now().format("%Y-%m-%d %H:%M:%S"), hostname, username);

        let readme_path = output_dir.join("README.md");
        std::fs::write(&readme_path, readme_content)?;
        generated_files.insert("README.md".to_string(), readme_path);

        Ok(generated_files)
    }
}

/// Validate NixOS configuration file
pub fn validate_config(config_path: &Path) -> Result<(bool, Vec<String>)> {
    let mut errors = Vec::new();

    if !config_path.exists() {
        errors.push(format!("Configuration file not found: {:?}", config_path));
        return Ok((false, errors));
    }

    // Check syntax with nix-instantiate
    let output = Command::new("nix-instantiate")
        .arg("--parse")
        .arg(config_path)
        .output()
        .context("Failed to execute nix-instantiate")?;

    if !output.status.success() {
        errors.push(format!("Syntax error: {}", String::from_utf8_lossy(&output.stderr)));
        return Ok((false, errors));
    }

    Ok((true, errors))
}

/// Test NixOS configuration in a VM
pub fn test_in_vm(config_dir: &Path) -> Result<bool> {
    let config_path = config_dir.join("configuration.nix");

    if !config_path.exists() {
        return Ok(false);
    }

    let output = Command::new("nixos-rebuild")
        .arg("build-vm")
        .arg("-I")
        .arg(format!("nixos-config={}", config_path.display()))
        .current_dir(config_dir)
        .output()
        .context("Failed to execute nixos-rebuild build-vm")?;

    Ok(output.status.success())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generator_new() {
        let generator = NixOSConfigGenerator::new(None);
        assert!(generator.capsule_dir.to_str().unwrap().contains(".capsule"));
    }

    #[test]
    fn test_detect_services() {
        let generator = NixOSConfigGenerator::new(None);
        let mut config = Config::default();
        config.presets.push("docker".to_string());

        let services = generator.detect_services(&config);
        assert!(services.contains_key("virtualisation.docker.enable"));
    }
}
